const express = require('express');
const cors = require('cors');
const mysql = require('mysql2/promise');
const http = require('http');
const socketIo = require('socket.io');
require('dotenv').config();

// Import des routes principales
const authRoutes = require('./routes/auth');
const clientsRoutes = require('./routes/clients');
const invoicesRoutes = require('./routes/invoices');
const usersRoutes = require('./routes/users');

// Import conditionnel des services et routes optionnels avec gestion d'erreur 
let notificationService;
let notificationRoutes;
let chatService;
let chatRoutes;
let assistantAmaniService;
let assistantRoutes;

// Chargement du service de notifications
try {
  notificationService = require('./services/notificationService');
  console.log('‚úÖ Service de notifications charg√© avec succ√®s');
} catch (error) {
  console.log('‚ö†Ô∏è Service de notifications non disponible:', error.code || error.message);
  notificationService = null;
}

// Chargement des routes notifications
try {
  notificationRoutes = require('./routes/notifications');
  console.log('‚úÖ Routes notifications charg√©es avec succ√®s');
} catch (error) {
  console.log('‚ö†Ô∏è Routes notifications non disponibles:', error.code || error.message);
  notificationRoutes = null;
}

// Chargement du service de chat
try {
  chatService = require('./services/chatService');
  console.log('‚úÖ Service de chat charg√© avec succ√®s');
} catch (error) {
  console.error('‚ùå ERREUR CRITIQUE: Service de chat non disponible:', error.message);
  console.error('Stack:', error.stack);
  chatService = null;
}

// Chargement des routes chat
try {
  chatRoutes = require('./routes/chat');
  console.log('‚úÖ Routes chat charg√©es avec succ√®s');
} catch (error) {
  console.error('‚ùå ERREUR CRITIQUE: Routes chat non disponibles:', error.message);
  console.error('Stack:', error.stack);
  chatRoutes = null;
}

// Chargement du service Assistant Amani
try {
  assistantAmaniService = require('./services/assistantAmaniService');
  console.log('‚úÖ Service Assistant Amani charg√© avec succ√®s');
} catch (error) {
  console.log('‚ö†Ô∏è Service Assistant Amani non disponible:', error.code || error.message);
  assistantAmaniService = null;
}

// Chargement des routes assistant
try {
  assistantRoutes = require('./routes/assistant');
  console.log('‚úÖ Routes Assistant Amani charg√©es avec succ√®s');
} catch (error) {
  console.log('‚ö†Ô∏è Routes Assistant Amani non disponibles:', error.code || error.message);
  assistantRoutes = null;
}

const app = express();
const PORT = process.env.PORT || 5000;

// Cr√©er le serveur HTTP
const server = http.createServer(app);

// Configuration Socket.io avec CORS
let io;
if (notificationService || chatService) {
  try {
    io = socketIo(server, {
      cors: {
        origin: process.env.FRONTEND_URL || 'http://localhost:3000',
        methods: ['GET', 'POST'],
        credentials: true,
        allowedHeaders: ['Content-Type', 'Authorization']
      },
      transports: ['websocket', 'polling'],
      pingTimeout: parseInt(process.env.WS_PING_TIMEOUT) || 60000,
      pingInterval: parseInt(process.env.WS_PING_INTERVAL) || 25000,
      connectTimeout: 45000,
      allowEIO3: true
    });

    console.log('üîó Socket.IO configur√© avec succ√®s');

    // Initialiser les services disponibles avec gestion d'erreur
    if (notificationService) {
      try {
        // Notifications sur le namespace par d√©faut
        notificationService.initialize(io);
        console.log('üîî Service de notifications initialis√© avec succ√®s');
      } catch (error) {
        console.error('‚ùå Erreur initialisation service notifications:', error);
        notificationService = null;
      }
    }

    if (chatService) {
      try {
        // Chat sur un namespace d√©di√©
        const chatNamespace = io.of('/chat');
        chatService.initialize(chatNamespace);
        console.log('üí¨ Service de chat initialis√© avec succ√®s');
      } catch (error) {
        console.error('‚ùå Erreur initialisation service chat:', error);
        chatService = null;
      }
    }

    // Gestion des connexions globales
    io.on('connection', (socket) => {
      console.log(`üîå Nouvelle connexion WebSocket: ${socket.id}`);
      
      socket.on('disconnect', (reason) => {
        console.log(`‚ùå D√©connexion WebSocket: ${socket.id} (${reason})`);
      });

      // Heartbeat pour garder la connexion alive
      socket.on('ping', () => {
        socket.emit('pong');
      });
    });

  } catch (error) {
    console.error('‚ùå Erreur critique initialisation WebSocket:', error);
    io = null;
  }
} else {
  console.log('‚ö†Ô∏è Aucun service WebSocket disponible - WebSocket non initialis√©');
}

// Configuration CORS pour Express
app.use(cors({
  origin: function(origin, callback) {
    // Permettre les requ√™tes sans origin (mobile apps, Postman, etc.)
    if (!origin) return callback(null, true);
    
    const allowedOrigins = [
      process.env.FRONTEND_URL || 'http://localhost:3000',
      'http://localhost:3000',
      'http://127.0.0.1:3000'
    ];
    
    if (allowedOrigins.indexOf(origin) !== -1) {
      callback(null, true);
    } else {
      console.log('üö´ Origin bloqu√©e:', origin);
      callback(null, false);
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept'],
  optionsSuccessStatus: 200
}));

// Middleware pour les requ√™tes preflight
app.options('*', cors());

// Middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Logger am√©lior√© avec plus de d√©tails
app.use((req, res, next) => {
  const timestamp = new Date().toISOString();
  const userAgent = req.get('User-Agent') || 'Unknown';
  const origin = req.get('Origin') || 'No-Origin';
  
  console.log(`${timestamp} - ${req.method} ${req.url} - Origin: ${origin}`);
  
  // Log des headers d'auth pour debug (sans exposer le token)
  if (req.headers.authorization) {
    console.log(`  - Auth: Bearer ${req.headers.authorization.substring(0, 20)}...`);
  }
  
  next();
});

// Middleware pour ajouter les services aux requ√™tes
app.use((req, res, next) => {
  if (notificationService) {
    req.notificationService = notificationService;
  }
  if (chatService) {
    req.chatService = chatService;
  }
  if (assistantAmaniService) {
    req.assistantAmaniService = assistantAmaniService;
  }
  next();
});

// Test de connexion MySQL
async function testDB() {
  try {
    const connection = await mysql.createConnection({
      host: process.env.DB_HOST || '127.0.0.1',
      port: process.env.DB_PORT || 3307,
      user: process.env.DB_USER || 'root', 
      password: process.env.DB_PASSWORD || '',
      database: process.env.DB_NAME || 'gestionFac'
    });
    
    // Test avec une requ√™te 
    await connection.execute('SELECT 1 as test');
    
    console.log('‚úÖ Connexion MySQL r√©ussie');
    console.log(`üì° Host: ${process.env.DB_HOST || '127.0.0.1'}:${process.env.DB_PORT || 3307}`);
    console.log(`üóÑÔ∏è  Base: ${process.env.DB_NAME || 'gestionFac'}`);
    
    await connection.end();
    return true;
  } catch (error) {
    console.error('‚ùå Erreur MySQL:', error.message);
    console.error('üîß V√©rifiez que MySQL est d√©marr√© et accessible');
    return false;
  }
}

// Routes principales
app.get('/', async (req, res) => {
  const notificationStats = notificationService ? notificationService.getConnectionStats() : { 
    connectedUsers: 0, 
    connectedClients: 0, 
    totalSockets: 0 
  };
  
  const chatStats = chatService ? chatService.getConnectionStats() : {
    totalConnected: 0,
    connectedClients: 0,
    connectedProfessionals: 0,
    activeConversations: 0
  };

  // Stats de l'assistant
  let assistantStats = null;
  if (assistantAmaniService) {
    try {
      assistantStats = await assistantAmaniService.getStats();
    } catch (error) {
      assistantStats = { enabled: false, error: error.message };
    }
  }
  
  res.json({
    message: 'API Amani - Syst√®me de Gestion des Factures avec Assistant IA',
    version: '1.1.0',
    status: 'running',
    services: {
      notifications: {
        service: notificationService ? 'active' : 'unavailable',
        connectedUsers: notificationStats.connectedUsers,
        connectedClients: notificationStats.connectedClients,
        totalSockets: notificationStats.totalSockets
      },
      chat: {
        service: chatService ? 'active' : 'unavailable',
        totalConnected: chatStats.totalConnected,
        connectedClients: chatStats.connectedClients,
        connectedProfessionals: chatStats.connectedProfessionals,
        activeConversations: chatStats.activeConversations,
        // Info assistant dans les stats chat
        assistant: chatStats.assistantAmani || null
      },
      // Section d√©di√©e √† l'assistant
      assistantAmani: assistantStats || {
        service: assistantAmaniService ? 'loaded' : 'unavailable',
        enabled: false,
        error: assistantAmaniService ? null : 'Service non charg√©'
      }
    },
    endpoints: [
      'GET /',
      'GET /api/health',
      
      // Auth endpoints
      'POST /api/auth/login/professional',
      'POST /api/auth/login/client',
      'POST /api/auth/logout',
      'GET /api/auth/profile',
      'GET /api/auth/verify',
      
      // Users endpoints 
      'GET /api/users',
      'GET /api/users/stats',
      'GET /api/users/:id',
      'POST /api/users',
      'PUT /api/users/:id',
      'PUT /api/users/:id/role',
      'PUT /api/users/:id/password',
      'POST /api/users/:id/toggle-status',
      'DELETE /api/users/:id',
      
      // Clients endpoints
      'GET /api/clients',
      'GET /api/clients/stats',
      'GET /api/clients/:id',
      'POST /api/clients',
      'PUT /api/clients/:id',
      'DELETE /api/clients/:id',
      'POST /api/clients/:id/toggle-status',
      
      // Invoices endpoints
      'GET /api/invoices',
      'GET /api/invoices/stats',
      'GET /api/invoices/:id',
      'GET /api/invoices/:id/pdf',
      'POST /api/invoices',
      'POST /api/invoices/:id/duplicate',
      'POST /api/invoices/:id/status',
      'PUT /api/invoices/:id',
      'DELETE /api/invoices/:id',
      
      // Admin Requests endpoints
      'GET /api/requests',
      'GET /api/requests/stats',
      'POST /api/requests/:id/approve-profile',
      'POST /api/requests/:id/reject-profile',
      'POST /api/requests/:id/approve-password',
      'POST /api/requests/:id/reject-password',
      
      // Chat endpoints
      ...(chatRoutes ? [
        'GET /api/chat/conversations - Liste des conversations',
        'POST /api/chat/conversations - Cr√©er une conversation (client)',
        'GET /api/chat/conversations/:id - D√©tails conversation',
        'GET /api/chat/conversations/:id/messages - Messages',
        'POST /api/chat/conversations/:id/close - Fermer (pro)',
        'POST /api/chat/conversations/:id/reopen - Rouvrir (pro)',
        'GET /api/chat/conversations/:id/participants - Participants',
        'GET /api/chat/stats - Statistiques (pro)'
      ] : ['‚ùå Chat endpoints non disponibles']),
      
      // Assistant endpoints
      ...(assistantRoutes ? [
        'GET /api/assistant/stats - Statistiques assistant (pro)',
        'POST /api/assistant/test - Tester l\'assistant (admin)',
        'GET /api/assistant/status - Statut de l\'assistant',
        'POST /api/assistant/toggle - Activer/d√©sactiver (admin)'
      ] : ['‚ùå Assistant endpoints non disponibles']),
      
      // Notifications endpoints
      ...(notificationRoutes ? [
        'GET /api/notifications',
        'POST /api/notifications/send',
        'PUT /api/notifications/:id/read',
        'DELETE /api/notifications/:id',
        'DELETE /api/notifications/clear-all',
        'GET /api/notifications/stats'
      ] : ['‚ùå Notification endpoints non disponibles'])
    ],
    websocket: (notificationService || chatService) ? {
      endpoint: '/socket.io/',
      status: 'active',
      events: [
        'connection',
        'disconnect',
        // Notifications
        ...(notificationService ? [
          'new_notification',
          'unread_notifications',
          'notifications_list',
          'mark_notification_read',
          'notification_deleted'
        ] : []),
        // Chat
        ...(chatService ? [
          'chat_authenticate - Authentification',
          'join_conversation - Rejoindre conversation',
          'leave_conversation - Quitter conversation',
          'send_message - Envoyer message',
          'new_message - Nouveau message re√ßu (incluant Assistant Amani)',
          'mark_messages_read - Marquer comme lu',
          'user_typing - Indicateur frappe',
          'typing_start/typing_stop - Contr√¥le frappe',
          'user_joined/user_left - Gestion participants'
        ] : []),
        'ping/pong - Heartbeat'
      ]
    } : {
      status: 'unavailable',
      reason: 'Aucun service WebSocket disponible'
    },
    // Information sp√©cifique sur l'assistant
    assistantAmani: {
      enabled: assistantStats?.enabled || false,
      model: process.env.OPENAI_MODEL || "gpt-4o-mini",
      activationCondition: "Aucun professionnel en ligne",
      features: [
        "R√©ponse automatique aux questions fr√©quentes",
        "Gestion des factures et paiements", 
        "Informations sur les services h√¥teliers",
        "Escalade intelligente vers les professionnels",
        "Support multilingue (fran√ßais)"
      ]
    },
    timestamp: new Date().toISOString()
  });
});

app.get('/api/health', async (req, res) => {
  const dbOk = await testDB();
  const notificationStats = notificationService ? notificationService.getConnectionStats() : { 
    connectedUsers: 0, 
    connectedClients: 0, 
    totalSockets: 0 
  };
  const chatStats = chatService ? chatService.getConnectionStats() : {
    totalConnected: 0,
    connectedClients: 0,
    connectedProfessionals: 0,
    activeConversations: 0
  };

  // Health check de l'assistant
  let assistantHealth = null;
  if (assistantAmaniService) {
    try {
      assistantHealth = await assistantAmaniService.getStats();
      assistantHealth.status = assistantHealth.enabled ? 'healthy' : 'disabled';
    } catch (error) {
      assistantHealth = {
        status: 'error',
        error: error.message
      };
    }
  } else {
    assistantHealth = {
      status: 'unavailable',
      reason: 'Service non charg√©'
    };
  }
  
  const healthStatus = {
    status: dbOk ? 'healthy' : 'degraded',
    database: dbOk ? 'Connected' : 'Error',
    services: {
      notifications: {
        status: notificationService ? 'running' : 'unavailable',
        connections: notificationStats
      },
      chat: {
        status: chatService ? 'running' : 'unavailable',
        connections: chatStats
      },
      // Health de l'assistant
      assistantAmani: assistantHealth
    },
    environment: {
      node_env: process.env.NODE_ENV || 'development',
      port: PORT,
      db_host: process.env.DB_HOST || '127.0.0.1',
      db_port: process.env.DB_PORT || 3307,
      // Variables d'environnement de l'assistant
      openai_configured: !!process.env.OPENAI_API_KEY,
      assistant_enabled: process.env.ASSISTANT_ENABLED === 'true'
    },
    timestamp: new Date().toISOString()
  };
  
  res.status(dbOk ? 200 : 503).json(healthStatus);
});

// Routes d'authentification
app.use('/api/auth', authRoutes);

// Routes de gestion des utilisateurs
app.use('/api/users', usersRoutes);

// Routes de gestion des clients
app.use('/api/clients', clientsRoutes);

// Routes de gestion des factures
app.use('/api/invoices', invoicesRoutes);

// Routes client (avec gestion d'erreur)
try {
  const clientRoutes = require('./routes/client');
  app.use('/api/client', clientRoutes);
  console.log('‚úÖ Routes client charg√©es et mont√©es sur /api/client');
} catch (error) {
  console.log('‚ö†Ô∏è Routes client non disponibles:', error.message);
  
  app.use('/api/client/*', (req, res) => {
    res.status(503).json({
      success: false,
      message: 'Service client temporairement indisponible',
      error: 'CLIENT_ROUTES_ERROR'
    });
  });
}

// Routes admin pour les demandes
try {
  const requestsRoutes = require('./routes/requests');
  app.use('/api/requests', requestsRoutes);
  console.log('‚úÖ Routes requests charg√©es et mont√©es sur /api/requests');
} catch (error) {
  console.log('‚ö†Ô∏è Routes requests non disponibles:', error.message);
  
  app.use('/api/requests/*', (req, res) => {
    res.status(503).json({
      success: false,
      message: 'Service de demandes administratives temporairement indisponible',
      error: 'REQUESTS_ROUTES_ERROR'
    });
  });
}

// Routes chat - Gestion avec fallback
if (chatRoutes && chatService) {
  try {
    app.use('/api/chat', chatRoutes);
    console.log('‚úÖ Routes chat mont√©es sur /api/chat avec succ√®s');
    
    console.log('üß™ Test des routes chat:');
    console.log('   ‚úÖ GET  /api/chat/conversations - Disponible');
    console.log('   ‚úÖ POST /api/chat/conversations - Disponible');  
    console.log('   ‚úÖ GET  /api/chat/stats - Disponible');
    console.log('   ‚úÖ WebSocket chat - Service actif');
    
  } catch (error) {
    console.error('‚ùå ERREUR CRITIQUE lors du montage des routes chat:', error);
    
    app.use('/api/chat/*', (req, res) => {
      console.error(`‚ùå Tentative d'acc√®s √† route chat indisponible: ${req.method} ${req.originalUrl}`);
      res.status(503).json({
        success: false,
        message: 'Service de chat temporairement indisponible',
        error: 'CHAT_ROUTES_MOUNT_ERROR',
        timestamp: new Date().toISOString()
      });
    });
  }
} else {
  console.error('‚ùå CHAT NON DISPONIBLE - Raisons possibles:');
  if (!chatRoutes) console.error('   - Routes chat non charg√©es');
  if (!chatService) console.error('   - Service chat non charg√©');
  
  app.use('/api/chat/*', (req, res) => {
    const reasons = [];
    if (!chatRoutes) reasons.push('Routes chat non charg√©es');
    if (!chatService) reasons.push('Service chat non initialis√©');
    
    console.log(`‚ö†Ô∏è Tentative d'acc√®s au chat: ${req.method} ${req.originalUrl}`);
    
    res.status(503).json({
      success: false,
      message: 'Service de chat non disponible',
      error: 'CHAT_SERVICE_UNAVAILABLE',
      reasons: reasons,
      timestamp: new Date().toISOString()
    });
  });
}

// Routes Assistant Amani
if (assistantRoutes && assistantAmaniService) {
  try {
    app.use('/api/assistant', assistantRoutes);
    console.log('‚úÖ Routes Assistant Amani mont√©es sur /api/assistant avec succ√®s');
    
    console.log('üß™ Test des routes Assistant Amani:');
    console.log('   ‚úÖ GET  /api/assistant/stats - Disponible');
    console.log('   ‚úÖ POST /api/assistant/test - Disponible');
    console.log('   ‚úÖ GET  /api/assistant/status - Disponible');
    console.log('   ‚úÖ Service Assistant Amani - Actif');
    
  } catch (error) {
    console.error('‚ùå ERREUR CRITIQUE lors du montage des routes Assistant Amani:', error);
    
    app.use('/api/assistant/*', (req, res) => {
      console.error(`‚ùå Tentative d'acc√®s √† route Assistant indisponible: ${req.method} ${req.originalUrl}`);
      res.status(503).json({
        success: false,
        message: 'Service Assistant Amani temporairement indisponible',
        error: 'ASSISTANT_ROUTES_MOUNT_ERROR',
        timestamp: new Date().toISOString()
      });
    });
  }
} else {
  console.error('‚ùå ASSISTANT AMANI NON DISPONIBLE - Raisons possibles:');
  if (!assistantRoutes) console.error('   - Routes Assistant non charg√©es');
  if (!assistantAmaniService) console.error('   - Service Assistant non charg√©');
  
  app.use('/api/assistant/*', (req, res) => {
    const reasons = [];
    if (!assistantRoutes) reasons.push('Routes Assistant non charg√©es');
    if (!assistantAmaniService) reasons.push('Service Assistant non initialis√©');
    
    console.log(`‚ö†Ô∏è Tentative d'acc√®s √† l'Assistant: ${req.method} ${req.originalUrl}`);
    
    res.status(503).json({
      success: false,
      message: 'Service Assistant Amani non disponible',
      error: 'ASSISTANT_SERVICE_UNAVAILABLE',
      reasons: reasons,
      suggestions: [
        'V√©rifiez que la cl√© OpenAI API est configur√©e dans .env',
        'Contr√¥lez les d√©pendances (npm install openai)',
        'V√©rifiez les param√®tres ASSISTANT_* dans .env',
        'Red√©marrez le serveur'
      ],
      timestamp: new Date().toISOString()
    });
  });
}

// Routes notifications
if (notificationRoutes && notificationService) {
  try {
    app.use('/api/notifications', notificationRoutes);
    console.log('‚úÖ Routes notifications mont√©es sur /api/notifications');
  } catch (error) {
    console.error('‚ùå Erreur montage routes notifications:', error);
    
    app.use('/api/notifications/*', (req, res) => {
      res.status(503).json({
        success: false,
        message: 'Service de notifications temporairement indisponible',
        error: 'NOTIFICATION_ROUTES_ERROR'
      });
    });
  }
}

// Route 404 am√©lior√©e
app.use('*', (req, res) => {
  const isApiRoute = req.originalUrl.startsWith('/api/');
  
  console.log(`‚ùå Route 404: ${req.method} ${req.originalUrl}`);

  const availableEndpoints = [
    '‚úÖ GET / - API info et statistiques',
    '‚úÖ GET /api/health - Sant√© du syst√®me',
    '‚úÖ POST /api/auth/login/professional - Connexion pro',
    '‚úÖ POST /api/auth/login/client - Connexion client'
  ];

  if (chatRoutes && chatService) {
    availableEndpoints.push('‚úÖ GET /api/chat/conversations - Chat (authentifi√©)');
    availableEndpoints.push('‚úÖ WebSocket /socket.io/ - Chat temps r√©el');
  }

  if (assistantRoutes && assistantAmaniService) {
    availableEndpoints.push('‚úÖ GET /api/assistant/stats - Assistant (pro auth)');
    availableEndpoints.push('‚úÖ GET /api/assistant/status - Statut assistant');
  }

  const response = {
    success: false,
    message: `Route non trouv√©e: ${req.method} ${req.originalUrl}`,
    availableEndpoints,
    debug: {
      services: {
        chatLoaded: !!chatService,
        assistantLoaded: !!assistantAmaniService,
        notificationLoaded: !!notificationService
      }
    },
    timestamp: new Date().toISOString()
  };

  res.status(404).json(response);
});

// Gestion erreurs globales
app.use((error, req, res, next) => {
  console.error('‚ùå Erreur serveur globale:', {
    message: error.message,
    stack: error.stack,
    url: req.originalUrl,
    method: req.method,
    timestamp: new Date().toISOString()
  });
  
  // Erreur de validation JSON
  if (error instanceof SyntaxError && error.status === 400) {
    return res.status(400).json({
      success: false,
      message: 'Format JSON invalide dans la requ√™te',
      error: 'INVALID_JSON'
    });
  }

  // Erreur de token JWT
  if (error.name === 'JsonWebTokenError') {
    return res.status(401).json({
      success: false,
      message: 'Token d\'authentification invalide',
      error: 'INVALID_TOKEN'
    });
  }

  // Erreur de base de donn√©es
  if (error.code && error.code.startsWith('ER_')) {
    return res.status(500).json({
      success: false,
      message: 'Erreur de base de donn√©es',
      error: 'DATABASE_ERROR'
    });
  }
  
  res.status(500).json({
    success: false,
    message: 'Erreur interne du serveur',
    error: 'INTERNAL_SERVER_ERROR',
    ...(process.env.NODE_ENV === 'development' && { 
      details: error.message,
      stack: error.stack 
    }),
    timestamp: new Date().toISOString()
  });
});

// D√©marrage serveur avec v√©rifications compl√®tes
async function startServer() {
  try {
    console.log('üöÄ D√©marrage du serveur Amani...');
    
    // Test base de donn√©es
    console.log('üìä V√©rification de la base de donn√©es...');
    const dbConnected = await testDB();
    
    if (!dbConnected) {
      console.error('‚ùå ERREUR CRITIQUE: Impossible de se connecter √† la base de donn√©es');
      process.exit(1);
    }
    
    // D√©marrer le serveur HTTP avec Socket.io
    server.listen(PORT, () => {
      console.log('\nüéâ==================================================üéâ');
      console.log(`üè® SERVEUR AMANI D√âMARR√â AVEC SUCC√àS`);
      console.log(`üåê Port: ${PORT}`);
      console.log(`üîó URL locale: http://localhost:${PORT}`);
      console.log(`‚öôÔ∏è  Environnement: ${process.env.NODE_ENV || 'development'}`);
      console.log(`üóÑÔ∏è  Base de donn√©es: ${process.env.DB_NAME || 'gestionFac'} ‚úÖ`);
      
      // Statut des services temps r√©el
      if (notificationService || chatService) {
        console.log(`üì° WebSocket: http://localhost:${PORT}/socket.io/ ‚úÖ`);
        console.log(`üîî Notifications temps r√©el: ${notificationService ? '‚úÖ ACTIF' : '‚ùå INACTIF'}`);
        console.log(`üí¨ Chat temps r√©el: ${chatService ? '‚úÖ ACTIF' : '‚ùå INACTIF'}`);
      } else {
        console.log(`üì° WebSocket: ‚ùå AUCUN SERVICE DISPONIBLE`);
      }
      
      console.log('üéâ==================================================üéâ');
      
      console.log('\nüîî √âtat d√©taill√© des services:');
      console.log(`- Base de donn√©es MySQL: ‚úÖ Connect√©e`);
      console.log(`- Authentification JWT: ‚úÖ Active`);
      console.log(`- WebSocket global: ${(notificationService || chatService) ? '‚úÖ Actif' : '‚ùå Inactif'}`);
      console.log(`- Service notifications: ${notificationService ? '‚úÖ Charg√©' : '‚ùå Non charg√©'}`);
      console.log(`- Service chat: ${chatService ? '‚úÖ Charg√©' : '‚ùå Non charg√©'}`);
      console.log(`- Routes chat: ${chatRoutes ? '‚úÖ Mont√©es' : '‚ùå Non mont√©es'}`);
      console.log(`- Assistant Amani: ${assistantAmaniService ? (assistantAmaniService.isEnabled() ? 'ü§ñ Actif' : '‚ö†Ô∏è Charg√© mais d√©sactiv√©') : '‚ùå Non charg√©'}`);
      console.log(`- Routes assistant: ${assistantRoutes ? '‚úÖ Mont√©es' : '‚ùå Non mont√©es'}`);
      console.log(`- Routes notifications: ${notificationRoutes ? '‚úÖ Mont√©es' : '‚ùå Non mont√©es'}`);
      console.log(`- Gestion des demandes admin: ‚úÖ Active`);
      
      console.log('\nüîó Pour tester le syst√®me:');
      console.log('üì± Frontend: http://localhost:3000');
      console.log('üåê API Info: http://localhost:5000');
      console.log('üíä Sant√© syst√®me: http://localhost:5000/api/health');
      
      if (chatRoutes && chatService) {
        console.log('üí¨ Test chat API: GET http://localhost:5000/api/chat/conversations');
      }
      
      if (assistantRoutes && assistantAmaniService) {
        console.log('ü§ñ Test assistant: GET http://localhost:5000/api/assistant/status');
      }
      
      console.log('================================');
      console.log('‚ú® Serveur pr√™t pour les connexions !');
      console.log('üîç Surveillez les logs pour les connexions WebSocket');
      console.log('================================\n');
    });
    
  } catch (error) {
    console.error('‚ùå Erreur critique lors du d√©marrage:', error);
    process.exit(1);
  }
}

// Gestion des signaux syst√®me
process.on('SIGINT', () => {
  console.log('\nüõë Signal SIGINT re√ßu, arr√™t du serveur...');
  server.close(() => {
    console.log('‚úÖ Serveur ferm√© proprement');
    process.exit(0);
  });
});

process.on('SIGTERM', () => {
  console.log('\nüõë Signal SIGTERM re√ßu, arr√™t du serveur...');
  server.close(() => {
    console.log('‚úÖ Serveur ferm√© proprement');
    process.exit(0);
  });
});

startServer();