const express = require('express');
const cors = require('cors');
const mysql = require('mysql2/promise');
const http = require('http');
const socketIo = require('socket.io');
require('dotenv').config();

// Import des routes principales
const authRoutes = require('./routes/auth');
const clientsRoutes = require('./routes/clients');
const invoicesRoutes = require('./routes/invoices');
const usersRoutes = require('./routes/users');

// Import conditionnel des services et routes optionnels avec gestion d'erreur 
let notificationService;
let notificationRoutes;
let chatService;
let chatRoutes;

// Chargement du service de notifications
try {
  notificationService = require('./services/notificationService');
  console.log('‚úÖ Service de notifications charg√© avec succ√®s');
} catch (error) {
  console.log('‚ö†Ô∏è Service de notifications non disponible:', error.code || error.message);
  notificationService = null;
}

// Chargement des routes notifications
try {
  notificationRoutes = require('./routes/notifications');
  console.log('‚úÖ Routes notifications charg√©es avec succ√®s');
} catch (error) {
  console.log('‚ö†Ô∏è Routes notifications non disponibles:', error.code || error.message);
  notificationRoutes = null;
}

// Chargement du service de chat
try {
  chatService = require('./services/chatService');
  console.log('‚úÖ Service de chat charg√© avec succ√®s');
} catch (error) {
  console.error('‚ùå ERREUR CRITIQUE: Service de chat non disponible:', error.message);
  console.error('Stack:', error.stack);
  chatService = null;
}

// Chargement des routes chat\
try {
  chatRoutes = require('./routes/chat');
  console.log('‚úÖ Routes chat charg√©es avec succ√®s');
} catch (error) {
  console.error('‚ùå ERREUR CRITIQUE: Routes chat non disponibles:', error.message);
  console.error('Stack:', error.stack);
  chatRoutes = null;
}

const app = express();
const PORT = process.env.PORT || 5000;

// Cr√©er le serveur HTTP
const server = http.createServer(app);

// Configuration Socket.io avec CORS
let io;
if (notificationService || chatService) {
  try {
    io = socketIo(server, {
      cors: {
        origin: process.env.FRONTEND_URL || 'http://localhost:3000',
        methods: ['GET', 'POST'],
        credentials: true,
        allowedHeaders: ['Content-Type', 'Authorization']
      },
      transports: ['websocket', 'polling'],
      pingTimeout: parseInt(process.env.WS_PING_TIMEOUT) || 60000,
      pingInterval: parseInt(process.env.WS_PING_INTERVAL) || 25000,
      connectTimeout: 45000,
      allowEIO3: true
    });

    console.log('üîó Socket.IO configur√© avec succ√®s');

    // Initialiser les services disponibles avec gestion d'erreur
if (notificationService) {
  try {
    // Notifications sur le namespace par d√©faut
    notificationService.initialize(io);
    console.log('üîî Service de notifications initialis√© avec succ√®s');
  } catch (error) {
    console.error('‚ùå Erreur initialisation service notifications:', error);
    notificationService = null;
  }
}

if (chatService) {
  try {
    // Chat sur un namespace d√©di√©
    const chatNamespace = io.of('/chat');
    chatService.initialize(chatNamespace);
    console.log('üí¨ Service de chat initialis√© avec succ√®s');
  } catch (error) {
    console.error('‚ùå Erreur initialisation service chat:', error);
    chatService = null;
  }
}

    // Gestion des connexions globales
    io.on('connection', (socket) => {
      console.log(`üîå Nouvelle connexion WebSocket: ${socket.id}`);
      
      socket.on('disconnect', (reason) => {
        console.log(`‚ùå D√©connexion WebSocket: ${socket.id} (${reason})`);
      });

      // Heartbeat pour garder la connexion alive
      socket.on('ping', () => {
        socket.emit('pong');
      });
    });

  } catch (error) {
    console.error('‚ùå Erreur critique initialisation WebSocket:', error);
    io = null;
  }
} else {
  console.log('‚ö†Ô∏è Aucun service WebSocket disponible - WebSocket non initialis√©');
}

// Configuration CORS pour Express
app.use(cors({
  origin: function(origin, callback) {
    // Permettre les requ√™tes sans origin (mobile apps, Postman, etc.)
    if (!origin) return callback(null, true);
    
    const allowedOrigins = [
      process.env.FRONTEND_URL || 'http://localhost:3000',
      'http://localhost:3000',
      'http://127.0.0.1:3000'
    ];
    
    if (allowedOrigins.indexOf(origin) !== -1) {
      callback(null, true);
    } else {
      console.log('üö´ Origin bloqu√©e:', origin);
      callback(null, false);
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept'],
  optionsSuccessStatus: 200
}));

// Middleware pour les requ√™tes preflight
app.options('*', cors());

// Middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Logger am√©lior√© avec plus de d√©tails
app.use((req, res, next) => {
  const timestamp = new Date().toISOString();
  const userAgent = req.get('User-Agent') || 'Unknown';
  const origin = req.get('Origin') || 'No-Origin';
  
  console.log(`${timestamp} - ${req.method} ${req.url} - Origin: ${origin}`);
  
  // Log des headers d'auth pour debug (sans exposer le token)
  if (req.headers.authorization) {
    console.log(`  - Auth: Bearer ${req.headers.authorization.substring(0, 20)}...`);
  }
  
  next();
});

// Middleware pour ajouter les services aux requ√™tes
app.use((req, res, next) => {
  if (notificationService) {
    req.notificationService = notificationService;
  }
  if (chatService) {
    req.chatService = chatService;
  }
  next();
});

// Test de connexion MySQL
async function testDB() {
  try {
    const connection = await mysql.createConnection({
      host: process.env.DB_HOST || '127.0.0.1',
      port: process.env.DB_PORT || 3307,
      user: process.env.DB_USER || 'root', 
      password: process.env.DB_PASSWORD || '',
      database: process.env.DB_NAME || 'gestionFac'
    });
    
    // Test avec une requ√™te 
    await connection.execute('SELECT 1 as test');
    
    console.log('‚úÖ Connexion MySQL r√©ussie');
    console.log(`üì° Host: ${process.env.DB_HOST || '127.0.0.1'}:${process.env.DB_PORT || 3307}`);
    console.log(`üóÑÔ∏è  Base: ${process.env.DB_NAME || 'gestionFac'}`);
    
    await connection.end();
    return true;
  } catch (error) {
    console.error('‚ùå Erreur MySQL:', error.message);
    console.error('üîß V√©rifiez que MySQL est d√©marr√© et accessible');
    return false;
  }
}

// Routes principales
app.get('/', (req, res) => {
  const notificationStats = notificationService ? notificationService.getConnectionStats() : { 
    connectedUsers: 0, 
    connectedClients: 0, 
    totalSockets: 0 
  };
  
  const chatStats = chatService ? chatService.getConnectionStats() : {
    totalConnected: 0,
    connectedClients: 0,
    connectedProfessionals: 0,
    activeConversations: 0
  };
  
  res.json({
    message: 'API Amani - Syst√®me de Gestion des Factures',
    version: '1.0.0',
    status: 'running',
    services: {
      notifications: {
        service: notificationService ? 'active' : 'unavailable',
        connectedUsers: notificationStats.connectedUsers,
        connectedClients: notificationStats.connectedClients,
        totalSockets: notificationStats.totalSockets
      },
      chat: {
        service: chatService ? 'active' : 'unavailable',
        totalConnected: chatStats.totalConnected,
        connectedClients: chatStats.connectedClients,
        connectedProfessionals: chatStats.connectedProfessionals,
        activeConversations: chatStats.activeConversations
      }
    },
    endpoints: [
      'GET /',
      'GET /api/health',
      
      // Auth endpoints
      'POST /api/auth/login/professional',
      'POST /api/auth/login/client',
      'POST /api/auth/logout',
      'GET /api/auth/profile',
      'GET /api/auth/verify',
      
      // Users endpoints 
      'GET /api/users',
      'GET /api/users/stats',
      'GET /api/users/:id',
      'POST /api/users',
      'PUT /api/users/:id',
      'PUT /api/users/:id/role',
      'PUT /api/users/:id/password',
      'POST /api/users/:id/toggle-status',
      'DELETE /api/users/:id',
      
      // Clients endpoints
      'GET /api/clients',
      'GET /api/clients/stats',
      'GET /api/clients/:id',
      'POST /api/clients',
      'PUT /api/clients/:id',
      'DELETE /api/clients/:id',
      'POST /api/clients/:id/toggle-status',
      
      // Invoices endpoints
      'GET /api/invoices',
      'GET /api/invoices/stats',
      'GET /api/invoices/:id',
      'GET /api/invoices/:id/pdf',
      'POST /api/invoices',
      'POST /api/invoices/:id/duplicate',
      'POST /api/invoices/:id/status',
      'PUT /api/invoices/:id',
      'DELETE /api/invoices/:id',
      
      // Admin Requests endpoints
      'GET /api/requests',
      'GET /api/requests/stats',
      'POST /api/requests/:id/approve-profile',
      'POST /api/requests/:id/reject-profile',
      'POST /api/requests/:id/approve-password',
      'POST /api/requests/:id/reject-password',
      
      // Chat endpoints
      ...(chatRoutes ? [
        'GET /api/chat/conversations - Liste des conversations',
        'POST /api/chat/conversations - Cr√©er une conversation (client)',
        'GET /api/chat/conversations/:id - D√©tails conversation',
        'GET /api/chat/conversations/:id/messages - Messages',
        'POST /api/chat/conversations/:id/close - Fermer (pro)',
        'POST /api/chat/conversations/:id/reopen - Rouvrir (pro)',
        'GET /api/chat/conversations/:id/participants - Participants',
        'GET /api/chat/stats - Statistiques (pro)'
      ] : ['‚ùå Chat endpoints non disponibles']),
      
      // Notifications endpoints
      ...(notificationRoutes ? [
        'GET /api/notifications',
        'POST /api/notifications/send',
        'PUT /api/notifications/:id/read',
        'DELETE /api/notifications/:id',
        'DELETE /api/notifications/clear-all',
        'GET /api/notifications/stats'
      ] : ['‚ùå Notification endpoints non disponibles'])
    ],
    websocket: (notificationService || chatService) ? {
      endpoint: '/socket.io/',
      status: 'active',
      events: [
        'connection',
        'disconnect',
        // Notifications
        ...(notificationService ? [
          'new_notification',
          'unread_notifications',
          'notifications_list',
          'mark_notification_read',
          'notification_deleted'
        ] : []),
        // Chat
        ...(chatService ? [
          'chat_authenticate - Authentification',
          'join_conversation - Rejoindre conversation',
          'leave_conversation - Quitter conversation',
          'send_message - Envoyer message',
          'new_message - Nouveau message re√ßu',
          'mark_messages_read - Marquer comme lu',
          'user_typing - Indicateur frappe',
          'typing_start/typing_stop - Contr√¥le frappe',
          'user_joined/user_left - Gestion participants'
        ] : []),
        'ping/pong - Heartbeat'
      ]
    } : {
      status: 'unavailable',
      reason: 'Aucun service WebSocket disponible'
    },
    timestamp: new Date().toISOString()
  });
});

app.get('/api/health', async (req, res) => {
  const dbOk = await testDB();
  const notificationStats = notificationService ? notificationService.getConnectionStats() : { 
    connectedUsers: 0, 
    connectedClients: 0, 
    totalSockets: 0 
  };
  const chatStats = chatService ? chatService.getConnectionStats() : {
    totalConnected: 0,
    connectedClients: 0,
    connectedProfessionals: 0,
    activeConversations: 0
  };
  
  const healthStatus = {
    status: dbOk ? 'healthy' : 'degraded',
    database: dbOk ? 'Connected' : 'Error',
    services: {
      notifications: {
        status: notificationService ? 'running' : 'unavailable',
        connections: notificationStats
      },
      chat: {
        status: chatService ? 'running' : 'unavailable',
        connections: chatStats
      }
    },
    environment: {
      node_env: process.env.NODE_ENV || 'development',
      port: PORT,
      db_host: process.env.DB_HOST || '127.0.0.1',
      db_port: process.env.DB_PORT || 3307
    },
    timestamp: new Date().toISOString()
  };
  
  res.status(dbOk ? 200 : 503).json(healthStatus);
});

// Routes d'authentification
app.use('/api/auth', authRoutes);

// Routes de gestion des utilisateurs
app.use('/api/users', usersRoutes);

// Routes de gestion des clients
app.use('/api/clients', clientsRoutes);

// Routes de gestion des factures
app.use('/api/invoices', invoicesRoutes);

// Routes client (avec gestion d'erreur)
try {
  const clientRoutes = require('./routes/client');
  app.use('/api/client', clientRoutes);
  console.log('‚úÖ Routes client charg√©es et mont√©es sur /api/client');
} catch (error) {
  console.log('‚ö†Ô∏è Routes client non disponibles:', error.message);
  
  // Route de fallback pour les erreurs client
  app.use('/api/client/*', (req, res) => {
    res.status(503).json({
      success: false,
      message: 'Service client temporairement indisponible',
      error: 'CLIENT_ROUTES_ERROR'
    });
  });
}

// Routes admin pour les demandes
try {
  const requestsRoutes = require('./routes/requests');
  app.use('/api/requests', requestsRoutes);
  console.log('‚úÖ Routes requests charg√©es et mont√©es sur /api/requests');
} catch (error) {
  console.log('‚ö†Ô∏è Routes requests non disponibles:', error.message);
  
  // Route de fallback pour les erreurs requests
  app.use('/api/requests/*', (req, res) => {
    res.status(503).json({
      success: false,
      message: 'Service de demandes administratives temporairement indisponible',
      error: 'REQUESTS_ROUTES_ERROR'
    });
  });
}

//  chat - Gestion avec fallback
if (chatRoutes && chatService) {
  try {
    app.use('/api/chat', chatRoutes);
    console.log('‚úÖ Routes chat mont√©es sur /api/chat avec succ√®s');
    
    // Test imm√©diat de disponibilit√©
    console.log('üß™ Test des routes chat:');
    console.log('   ‚úÖ GET  /api/chat/conversations - Disponible');
    console.log('   ‚úÖ POST /api/chat/conversations - Disponible');  
    console.log('   ‚úÖ GET  /api/chat/stats - Disponible');
    console.log('   ‚úÖ WebSocket chat - Service actif');
    
  } catch (error) {
    console.error('‚ùå ERREUR CRITIQUE lors du montage des routes chat:', error);
    console.error('Stack trace:', error.stack);
    
    // Routes de fallback d√©taill√©es pour √©viter 404
    app.use('/api/chat/*', (req, res) => {
      console.error(`‚ùå Tentative d'acc√®s √† route chat indisponible: ${req.method} ${req.originalUrl}`);
      res.status(503).json({
        success: false,
        message: 'Service de chat temporairement indisponible',
        error: 'CHAT_ROUTES_MOUNT_ERROR',
        details: 'Les routes de chat n\'ont pas pu √™tre mont√©es correctement',
        timestamp: new Date().toISOString()
      });
    });
  }
} else {
  console.error('‚ùå CHAT NON DISPONIBLE - Raisons possibles:');
  if (!chatRoutes) console.error('   - Routes chat non charg√©es');
  if (!chatService) console.error('   - Service chat non charg√©');
  
  // Routes de fallback informatives
  app.use('/api/chat/*', (req, res) => {
    const reasons = [];
    if (!chatRoutes) reasons.push('Routes chat non charg√©es');
    if (!chatService) reasons.push('Service chat non initialis√©');
    
    console.log(`‚ö†Ô∏è Tentative d'acc√®s au chat: ${req.method} ${req.originalUrl}`);
    
    res.status(503).json({
      success: false,
      message: 'Service de chat non disponible',
      error: 'CHAT_SERVICE_UNAVAILABLE',
      reasons: reasons,
      details: 'Le service de chat n\'a pas pu √™tre initialis√©. V√©rifiez les logs serveur.',
      suggestions: [
        'V√©rifiez que tous les fichiers de chat sont pr√©sents',
        'Contr√¥lez les d√©pendances (socket.io, etc.)',
        'Red√©marrez le serveur',
        'Consultez les logs de d√©marrage'
      ],
      timestamp: new Date().toISOString()
    });
  });
}

// Routes notifications
if (notificationRoutes && notificationService) {
  try {
    app.use('/api/notifications', notificationRoutes);
    console.log('‚úÖ Routes notifications mont√©es sur /api/notifications');
  } catch (error) {
    console.error('‚ùå Erreur montage routes notifications:', error);
    
    app.use('/api/notifications/*', (req, res) => {
      res.status(503).json({
        success: false,
        message: 'Service de notifications temporairement indisponible',
        error: 'NOTIFICATION_ROUTES_ERROR'
      });
    });
  }
} else if (notificationRoutes || notificationService) {
  // Au moins un composant est charg√© mais pas l'autre
  app.use('/api/notifications/*', (req, res) => {
    res.status(503).json({
      success: false,
      message: 'Service de notifications partiellement disponible',
      error: 'NOTIFICATION_PARTIAL_LOAD',
      details: {
        routes: !!notificationRoutes,
        service: !!notificationService
      }
    });
  });
}

// Route 404 am√©lior√©e avec diagnostics d√©taill√©s
app.use('*', (req, res) => {
  const isApiRoute = req.originalUrl.startsWith('/api/');
  
  // Log d√©taill√© pour d√©bugger
  console.log(`‚ùå Route 404: ${req.method} ${req.originalUrl}`);
  console.log(`   - User Agent: ${req.get('User-Agent') || 'Non sp√©cifi√©'}`);
  console.log(`   - Origin: ${req.get('Origin') || 'Non sp√©cifi√©'}`);
  console.log(`   - Referer: ${req.get('Referer') || 'Non sp√©cifi√©'}`);

  const availableEndpoints = [
    '‚úÖ GET / - API info et statistiques',
    '‚úÖ GET /api/health - Sant√© du syst√®me',
    '‚úÖ POST /api/auth/login/professional - Connexion pro',
    '‚úÖ POST /api/auth/login/client - Connexion client'
  ];

  // Ajouter les endpoints selon la disponibilit√© des services
  if (chatRoutes && chatService) {
    availableEndpoints.push('‚úÖ GET /api/chat/conversations - Chat (authentifi√©)');
    availableEndpoints.push('‚úÖ POST /api/chat/conversations - Cr√©er conversation (client)');
    availableEndpoints.push('‚úÖ WebSocket /socket.io/ - Chat temps r√©el');
  } else {
    availableEndpoints.push('‚ùå Chat endpoints non disponibles');
  }

  if (notificationService) {
    availableEndpoints.push('‚úÖ WebSocket /socket.io/ - Notifications temps r√©el');
  }

  const response = {
    success: false,
    message: `Route non trouv√©e: ${req.method} ${req.originalUrl}`,
    availableEndpoints,
    debug: {
      method: req.method,
      path: req.originalUrl,
      isApiRoute,
      services: {
        chatRoutesLoaded: !!chatRoutes,
        chatServiceLoaded: !!chatService,
        notificationServiceLoaded: !!notificationService,
        notificationRoutesLoaded: !!notificationRoutes
      }
    },
    suggestions: isApiRoute ? [
      'V√©rifiez l\'URL de l\'endpoint',
      'Consultez la liste des endpoints disponibles',
      'V√©rifiez que le service requis est actif'
    ] : [
      'Cette API ne sert que des endpoints /api/*',
      'Consultez GET / pour la liste compl√®te des endpoints'
    ],
    timestamp: new Date().toISOString()
  };

  res.status(404).json(response);
});

// Gestion erreurs globales
app.use((error, req, res, next) => {
  console.error('‚ùå Erreur serveur globale:', {
    message: error.message,
    stack: error.stack,
    url: req.originalUrl,
    method: req.method,
    timestamp: new Date().toISOString()
  });
  
  // Erreur de validation JSON
  if (error instanceof SyntaxError && error.status === 400) {
    return res.status(400).json({
      success: false,
      message: 'Format JSON invalide dans la requ√™te',
      error: 'INVALID_JSON'
    });
  }

  // Erreur de token JWT
  if (error.name === 'JsonWebTokenError') {
    return res.status(401).json({
      success: false,
      message: 'Token d\'authentification invalide',
      error: 'INVALID_TOKEN'
    });
  }

  // Erreur de base de donn√©es
  if (error.code && error.code.startsWith('ER_')) {
    return res.status(500).json({
      success: false,
      message: 'Erreur de base de donn√©es',
      error: 'DATABASE_ERROR'
    });
  }
  
  res.status(500).json({
    success: false,
    message: 'Erreur interne du serveur',
    error: 'INTERNAL_SERVER_ERROR',
    ...(process.env.NODE_ENV === 'development' && { 
      details: error.message,
      stack: error.stack 
    }),
    timestamp: new Date().toISOString()
  });
});

// D√©marrage serveur avec v√©rifications compl√®tes
async function startServer() {
  try {
    console.log('üöÄ D√©marrage du serveur Amani...');
    
    // Test base de donn√©es
    console.log('üìä V√©rification de la base de donn√©es...');
    const dbConnected = await testDB();
    
    if (!dbConnected) {
      console.error('‚ùå ERREUR CRITIQUE: Impossible de se connecter √† la base de donn√©es');
      console.log('üîß Suggestions pour corriger:');
      console.log('1. V√©rifiez que MySQL/MariaDB est d√©marr√©');
      console.log('2. Contr√¥lez les param√®tres dans le fichier .env:');
      console.log(`   - DB_HOST=${process.env.DB_HOST || '127.0.0.1'}`);
      console.log(`   - DB_PORT=${process.env.DB_PORT || '3307'}`);
      console.log(`   - DB_NAME=${process.env.DB_NAME || 'gestionFac'}`);
      console.log('3. Testez manuellement: mysql -h 127.0.0.1 -P 3307 -u root -p');
      console.log('4. V√©rifiez que la base "gestionFac" existe');
      process.exit(1);
    }
    
    // D√©marrer le serveur HTTP avec Socket.io
    server.listen(PORT, () => {
      console.log('\nüéâ==================================================üéâ');
      console.log(`üè® SERVEUR AMANI D√âMARR√â AVEC SUCC√àS`);
      console.log(`üåê Port: ${PORT}`);
      console.log(`üîó URL locale: http://localhost:${PORT}`);
      console.log(`‚öôÔ∏è  Environnement: ${process.env.NODE_ENV || 'development'}`);
      console.log(`üóÑÔ∏è  Base de donn√©es: ${process.env.DB_NAME || 'gestionFac'} ‚úÖ`);
      
      // Statut des services temps r√©el
      if (notificationService || chatService) {
        console.log(`üì° WebSocket: http://localhost:${PORT}/socket.io/ ‚úÖ`);
        console.log(`üîî Notifications temps r√©el: ${notificationService ? '‚úÖ ACTIF' : '‚ùå INACTIF'}`);
        console.log(`üí¨ Chat temps r√©el: ${chatService ? '‚úÖ ACTIF' : '‚ùå INACTIF'}`);
      } else {
        console.log(`üì° WebSocket: ‚ùå AUCUN SERVICE DISPONIBLE`);
      }
      
      console.log('üéâ==================================================üéâ');
      
      console.log('\nüìã Routes principales disponibles:');
      console.log('- ‚úÖ GET  / (Infos API + statistiques temps r√©el)');
      console.log('- ‚úÖ GET  /api/health (Sant√© syst√®me + diagnostics)');
      console.log('- ‚úÖ POST /api/auth/login/professional (Connexion √©quipe)');
      console.log('- ‚úÖ POST /api/auth/login/client (Connexion clients)');
      console.log('- ‚úÖ GET  /api/requests (Demandes admin - auth requise)');
      
      if (chatRoutes && chatService) {
        console.log('- ‚úÖ GET  /api/chat/conversations (Liste conversations - auth)');
        console.log('- ‚úÖ POST /api/chat/conversations (Cr√©er conversation client - auth)');
        console.log('- ‚úÖ GET  /api/chat/stats (Statistiques chat professionnels - auth)');
        console.log('- ‚úÖ WebSocket chat temps r√©el disponible');
      } else {
        console.log('- ‚ùå Routes chat NON DISPONIBLES');
        console.log('  Raisons: Service ou routes non charg√©s');
      }
      
      if (notificationService) {
        console.log('- ‚úÖ WebSocket notifications temps r√©el disponible');
      }
      
      console.log('\nüîî √âtat d√©taill√© des services:');
      console.log(`- Base de donn√©es MySQL: ‚úÖ Connect√©e`);
      console.log(`- Authentification JWT: ‚úÖ Active`);
      console.log(`- WebSocket global: ${(notificationService || chatService) ? '‚úÖ Actif' : '‚ùå Inactif'}`);
      console.log(`- Service notifications: ${notificationService ? '‚úÖ Charg√©' : '‚ùå Non charg√©'}`);
      console.log(`- Service chat: ${chatService ? '‚úÖ Charg√©' : '‚ùå Non charg√©'}`);
      console.log(`- Routes chat: ${chatRoutes ? '‚úÖ Mont√©es' : '‚ùå Non mont√©es'}`);
      console.log(`- Routes notifications: ${notificationRoutes ? '‚úÖ Mont√©es' : '‚ùå Non mont√©es'}`);
      console.log(`- Gestion des demandes admin: ‚úÖ Active`);
      
      console.log('\nüîó Pour tester le syst√®me:');
      console.log('üì± Frontend: http://localhost:3000');
      console.log('üåê API Info: http://localhost:5000');
      console.log('üíä Sant√© syst√®me: http://localhost:5000/api/health');
      console.log('üîê Test connexion: POST http://localhost:5000/api/auth/login/professional');
      
      if (chatRoutes && chatService) {
        console.log('üí¨ Test chat API: GET http://localhost:5000/api/chat/conversations');
        console.log('   (N√©cessite un token d\'authentification valide)');
      } else {
        console.log('‚ùå Chat API non testable - Service indisponible');
      }
      
      console.log('================================');
      console.log('‚ú® Serveur pr√™t pour les connexions !');
      console.log('üîç Surveillez les logs pour les connexions WebSocket');
      console.log('================================\n');
    });
    
  } catch (error) {
    console.error('‚ùå Erreur critique lors du d√©marrage:', error);
    console.error('Stack:', error.stack);
    process.exit(1);
  }
}

// Gestion des signaux syst√®me
process.on('SIGINT', () => {
  console.log('\nüõë Signal SIGINT re√ßu, arr√™t du serveur...');
  server.close(() => {
    console.log('‚úÖ Serveur ferm√© proprement');
    process.exit(0);
  });
});

process.on('SIGTERM', () => {
  console.log('\nüõë Signal SIGTERM re√ßu, arr√™t du serveur...');
  server.close(() => {
    console.log('‚úÖ Serveur ferm√© proprement');
    process.exit(0);
  });
});

startServer();